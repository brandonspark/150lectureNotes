% Jacob Neumann

% DOCUMENT CLASS AND PACKAGE USE
    \documentclass[aspectratio=169, handout]{beamer}

    % Establish the colorlambda boolean, to control whether the lambda is solid color (true), or the same as the picture (false)
    \newif\ifcolorlambda
    \colorlambdafalse % DEFAULT: false

    % Use auxcolor for syntax highlighting
    \newif\ifuseaux
    \useauxfalse % DEFAULT: false

    % Color settings
    \useauxtrue

    \newcommand{\auxColor}{F48C6B}     % the color of note boxes and stuff
    \newcommand{\presentColor}{A827E4} % the primary color of the slide borders
    \newcommand{\bgColor}{eee6ff}      % the color of the background of the slide
    \newcommand{\darkBg}{8b98ad}
    \newcommand{\lambdaColor}{\auxColor}

    \colorlambdatrue

    \usepackage{comment} % comment blocks
    \usepackage{soul} % strikethrough
    \usepackage{listings} % code
    \usepackage{makecell}

    \setbeamertemplate{itemize items}[circle]
    % \setbeameroption{show notes on second screen=right}

    \usepackage{lectureSlides}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%| <----- Don't make the title any longer than this
    \title{Exceptions} % TODO
    \subtitle{Breaking the rules of evaluation} % TODO
    \date{22 June 2023} % TODO
    \author{Brandon Wu} % TODO

    \graphicspath{ {./img/} }
    % DONT FORGET TO PUT [fragile] on frames with codeblocks, specs, etc.
        %\begin{frame}[fragile]
        %\begin{codeblock}
        %fun fact 0 = 1
        %  | fact n = n * fact(n-1)
        %\end{codeblock}
        %\end{frame}

    % INCLUDING codefile:
        % 1. In some file under code/NN (where NN is the lecture id num), include:
    %       (* FRAGMENT KK *)
    %           <CONTENT>
    %       (* END KK *)

    %    Remember to not put anything on the same line as the FRAGMENT or END comment, as that won't be included. KK here is some (not-zero-padded) integer. Note that you MUST have fragments 0,1,...,KK-1 defined in this manner in order for fragment KK to be properly extracted.
        %  2. On the slide where you want code fragment K
                % \smlFrag[color]{KK}
        %     where 'color' is some color string (defaults to 'white'. Don't use presentColor.
    %  3. If you want to offset the line numbers (e.g. have them start at line 5 instead of 1), use
                % \smlFragOffset[color]{KK}{5}

\begin{document}

% Make it so ./mkWeb works correctly
\ifweb
    \renewcommand{\pause}{}
\fi

\setbeamertemplate{itemize items}[circle]

% SOLID COLOR TITLE (see SETTINGS.sty)
{
\begin{frame}[plain]
    \colorlambdatrue
    \titlepage
\end{frame}
}

\menti{8455 6572}

\begin{frame}[fragile]
  \frametitle{Lesson Plan}

  \tableofcontents
\end{frame}

\begin{frame}[fragile]
  \frametitle{Last time}

  Last time, we learned about \term{continuation-passing style}. We learned that
  we could make our control flow even more explicit by, instead of implicitly
  using the return values of recursive functions, instead passing lambda expressions
  (\term{continuations}) denoting the computation to be done next to those recursive functions.

  \pause
  \vspace{\fill}

  This separated concerns when it came to functions which had branching control
  flow behavior, as well as allowing us to achieve clean tail-recursive code,
  by drawing a distinction between \textbf{writing now} and \textbf{remembering later}.

  \pause
  \vspace{\fill}

  We carried out a mechanistic process of CPS translation on various functions to
  achieve this.
\end{frame}

\sectionSlide{1}{Exceptions}

\begin{frame}[fragile]
  \frametitle{Extensional Behaviors}

  Recall our definition for all the possible behaviors of an expression: \pause
  \begin{itemize}
    \item Evaluate to a value \pause
    \item Loop forever \pause
    \item \textbf{Raise an exception}
  \end{itemize}

  \pause
  \vspace{\fill}

  Until now, we've given an intentionally bare bones treatment of
  exceptions. Now, it is time to dive into exceptions in more detail.
\end{frame}

\begin{frame}[fragile]
  \frametitle{An Exceptional Language}

  One of the first examples of expressions that we ever saw was the
  expression \code{1 div 0}. This expression raises an exception,
  when evaluated.

  \pause
  \vspace{\fill}

  \begin{codeblock}
    Standard ML of New Jersey (64-bit) v110.99.3 [built: Thu Jul 28 00:35:16 2022]
    - 1 div 0;

    uncaught exception Div [divide by zero]
      raised at: stdIn:1.4-1.7
  \end{codeblock}

  \pause
  \vspace{\fill}

  Exceptions are baked into many common processes in SML. In fact, there are
  three very essential ones we will discuss today!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Kinds of Exceptions}

  We see exceptions like \code{Div}, which are specific to certain functions.

  \pause
  \vspace{\fill}

  There are more fundamental exceptions which are raised upon given patterns
  of behaviors in SML. These exceptions are:
  \pause
  \begin{enumerate}
    \item \code{Match}, which is raised when a nonexhaustive match receives
    an input that fails to match any of its cases \pause
    \item \code{Bind}, which is raised when a \code{val} binding tries to
    bind something matching a particular pattern, and receives one which
    does not match
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The \code{Match} Exception}

  If you were to write the following lambda expression in SML:
  \begin{codeblock}
    val f = fn 1 => 2
  \end{codeblock}

  you would receive the following warning:
  \pause
  \begin{codeblock}
    stdIn:1.10-1.19 Warning: match nonexhaustive
              1 => ...
  \end{codeblock}

  \pause
  \vspace{\fill}

  What happened? We didn't specify what would happen on all possible inputs!
  The function is only defined on the input \code{1}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{The \code{Match} Exception}

  This is perfectly legal, and SML will let you proceed, but upon being given
  an invalid input:
  \pause
  \begin{codeblock}
    - f 2;

    uncaught exception Match [nonexhaustive match failure]
      raised at: stdIn:1.19
  \end{codeblock}
  we get an exception \code{Match}.

  \pause
  \vspace{\fill}

  In essence, you could think of all such nonexhaustive cases (and this function,
  in particular) as being defined implicitly as
  \pause
  \begin{codeblock}
    fn 1 => 2 | _ => raise Match
  \end{codeblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The \code{Bind} Exception}

  An archaic way of writing test cases is to try to bind an expression to a
  constant pattern:
  \begin{codeblock}
    val 6 = fact 3
  \end{codeblock}

  \pause
  \vspace{\fill}

  This will proceed without a hitch. If the pattern were to not match the
  returned value, however:

  \begin{codeblock}
    - val 5 = fact 3;
    stdIn:3.5-3.15 Warning: binding not exhaustive
              5 = ...

    uncaught exception Bind [nonexhaustive binding failure]
      raised at: stdIn:3.5-3.15
  \end{codeblock}

  we would now get an exception \code{Bind} being raised.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Why Exceptions?}

  We see that \code{Bind} and \code{Match} are more consequences
  of programming in SML, and aren't specific to any functions' logic.

  \pause
  \vspace{\fill}

  For exceptions like \code{Div}, we use them to \textit{escape} from
  having to return a value, when given some input. Instead of returning
  a value, we simply abort execution.

  \pause
  \vspace{\fill}

  At this point in the semester, we have seen functions which return
  optional values, which might beg the question -- why use exceptions
  in the first place?
\end{frame}


\begin{frame}[fragile]
  \frametitle{Exceptions versus Options}

  We see that for any function which raises exceptions, we can produce
  an equivalent function which returns an optional value, which instead
  returns \code{NONE} in any exceptional cases:

  \pause
  \begin{codeblock}
    infix safeDiv

    fun n safeDiv 0 = NONE
      | n safeDiv d = SOME (n div d)
  \end{codeblock}

  \pause
  \vspace{\fill}

  Why use exceptions at all, then, when they might cause a program to
  unexpectedly crash?
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Difference in Specification}

  Let's take a look at the following specifications:

  \pause
  \spec
    {div}
    {int * int -> int}
    {\code{n <> 0}}
    {\code{div (n, d)} evaluates to the
    floor of \code{n} divided by \code{d}}

  \pause
  \spec
    {safeDiv}
    {int * int -> int option}
    {\code{true}}
    {\code{safeDiv (n, d)} evaluates to \code{NONE} if \code{d} is \code{0},
    and \code{SOME (n div 0)} otherwise}

  \pause
  They look rather similar! The difference is that \code{safeDiv} has
  moved the precondition into the type of its return value.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Composing with Preconditions versus Types}

  \tgs

  In practice, \code{safeDiv} turns out to be the safer option,
  to no surprise.

  \pause
  \vspace{\fill}

  Forcing the caller to handle the exceptional case by handling the
  \code{NONE} is a \textbf{type-level distinction}, that causes code which
  does not acknowledge the possible failure to not compile.

  \pause
  \vspace{\fill}

  This is a really strong enforcement, and leads to code which cannot
  fail to address the failure!
\end{frame}

\begin{frame}[fragile]
  \frametitle{An Exceptional Calculation}

  Occasionally, however, this can prove to be more of a burden than a
  safety net.

  \pause
  \vspace{\fill}

  For instance, we might have occasions where we know for sure that
  an exceptional case cannot be reached. Suppose we are implementing
  the following function to collect the average grade of every
  student in 150:

  \pause
  \begin{codeblock}
    fun averageGrade (grades : int list) : int =
      (List.foldr op+ 0 grades)
      div
      (List.length grades)
  \end{codeblock}

  \pause
  \vspace{\fill}

  Suppose that we wanted to be rid of exceptions, however:
\end{frame}

\begin{frame}[fragile]
  \frametitle{An Optional Calculation}

  \begin{codeblock}
    fun averageGrades`Safe` (grades : int list) : `int option` =
      (List.foldr op+ 0 grades)
      `safeDiv`
      (List.length grades)
  \end{codeblock}

  \pause
  \vspace{\fill}

  Now, it is the responsibility of the caller to handle the \code{NONE} case!

  \pause
  \vspace{\fill}

  The only sensible thing to do (if not raising an exception) is often just to
  propagate the \code{option}, and cause all of the dependencies to also need
  to return optional values.

  \pause
  \vspace{\fill}

  This quickly gets messy.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implicit Preconditions}

  The thing is, this entire mess was never really necessary.

  \pause
  \vspace{\fill}

  Unless something is deeply wrong, it's a fairly safe bet that
  the database containing grade data for the entire class
  isn't empty.\footnote{
    If it is, I have bigger problems.
  }

  \pause
  \vspace{\fill}

  At a certain point, we need to be able to trust the data that we input.
  Although there is the \textit{possibility} of a failure case, in realistic
  situations, quite often there is no reason to believe that they are possible.

  \pause
  \vspace{\fill}

  So in this case, we might prefer the exceptional behavior, because it leads
  to cleaner code in a hypothetically impossible case. We have an
  \textit{implicit precondition} on our inputs.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Footguns}

  This is exactly the logic that has caused a million and one bugs in production
  code before.

  \pause
  \vspace{\fill}

  This is why judicious use of exceptions is important! In some cases, it really
  is OK to raise an exception in a failure case, depending on how bad the
  failure case is.

  \pause
  \vspace{\fill}

  It might seem that an unrecoverable error that completely crashes the
  running process might be worth no amount of code golfing. Luckily,
  SML does have ways of dealing with raised exceptions.
\end{frame}

\sectionSlide{2}{Using Exceptions}

\begin{frame}[fragile]
  \frametitle{Raising Exceptions}

  We can raise exceptions ourselves, as you may have seen many times before.

  \pause
  \vspace{\fill}

  What expressions are we allowed to raise? SML has a type of exception values,
  which is called \code{exn}. This may stand for "exception name".

  \pause
  \vspace{\fill}

  So for instance, valid constant constructors of type \code{exn} include:
  \begin{itemize}
    \item \code{Match}
    \item \code{Bind}
    \item \code{Div}
  \end{itemize}

  \pause
  but not \code{Fail : string -> exn}, which takes in an additional argument
  of type \code{string} before it can be raised.

  \pause
  \vspace{\fill}

  We use the syntax \code{raise e} to raise exception \code{e}, given that
  \code{e : exn}.

  \pause
  \vspace{\fill}

  \noteBox{\,}{\code{raise} is not a function, it merely looks like one. So
  \code{List.map raise} is not a valid expression.}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Typing \code{raise}}

  We said that \code{raise e} is an expression which raises the expression
  \code{e}. To evaluate, however, it needs to have a type, but what should
  its type be?

  \pause
  \vspace{\fill}

  Given that it never returns a value, it doesn't actually matter. For our
  purposes, it's important to use that an expression of type \code{t}
  returns a value of type \code{t}, \textit{if it returns at all}.

  \pause
  \vspace{\fill}

  Since \code{raise} never returns, we are free to give it any type. So
  \code{raise e} has type \code{'a}, in that it can take on any type.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Handling Exceptions}

  SML provides a language construct called \code{handle}. Here's an example
  of how we might use it, instead:

  \pause
  \begin{codeblock}
    fun reportGrades (grades : (string * int) list) =
      (let
        val grades = List.map snd records
      in
        "The average was " ^ Int.toString (averageGrade grades)
      end)
      handle Div => "ERROR: No grades found"
  \end{codeblock}

  \pause
  \vspace{\fill}

  In this case, we use \code{handle} to evaluate the body of the function to
  an error string in the case where \code{Div} is raised. Otherwise, we
  evaluate normally.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Handling, Generally}

  A \code{handle} expression has the following behaviors:

  \pause
  \vspace{\fill}

  The expression
  \begin{codeblock}
    e handle p1 => e1 | ... | pn => en
  \end{codeblock}

  has type \code{t} only if \code{e : t}, \code{e1 : t}, ..., \code{en : t}.

  \pause
  \vspace{5pt}

  In addition, \code{p1}, ..., \code{pn} must all be patterns of type
  \code{exn}.

  \pause
  \vspace{\fill}

  The behavior of the above \code{handle} expression is that: \pause
  \begin{itemize}
    \item If the expression \code{e} never raises an exception, then it
    evaluates to \code{e} \pause
    \item If the expression \code{e} raises exception \code{ex}, then
    it matches to the first \code{pi} that matches \code{ex} \pause
    \item If the exception \code{e} raises matches none of the
    \code{handle} cases, it raises that exception again
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A \code{handle} Example}

  Here are some examples of \code{handle} expressions, and how they evaluate:

  \pause
  \vspace{\fill}

  \begin{itemize}
    \item \code{raise Div} raises exception \code{Div}
    \item \code{(raise Div) handle Div => 2} $\hookrightarrow$ \code{2}
    \item \code{(raise Div) handle Bind => 2} raises exception \code{Div}
    \item \code{(raise Div) handle Bind => 1 | Div => 2} $\hookrightarrow$ \code{2}
    \item \code{2 handle Div => 3} $\hookrightarrow$ \code{3}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Nested Exception Raising}

  \rprs

  The great strength of \code{handle} is that it can be used to handle
  exceptions from \textit{anywhere inside of the enclosing expression}.

  \pause
  \vspace{\fill}

  \keyBox{}{For non \code{handle} expressions, if a sub-expression
  raises an exception, then that expression does too.}

  \pause
  \vspace{\fill}

  This means that exceptions \textit{propagate outwards} from where
  they were initially raised. This process continues until they reach
  the \textit{nearest enclosing handler}, at which point they are
  possibly handled, or keep going.

  \pause
  \vspace{\fill}

  This means that, essentially, exceptions allow a program to stop
  doing what it is doing, and resume control flow at an earlier point
  in time.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Nonlocal Control Flow}

  So in the expression \code{1 + (3 * (4 div 0)) handle Div => 5}:

  \pause
  \vspace{\fill}

  The expression \code{4 div 0} raises \code{Div}.

  \pause
  \vspace{3pt}

  The sub-expression \code{4 div 0} of \code{3 * (4 div 0)} raises \code{Div},
  so \code{3 * (4 div 0)} raises it too.

  \pause
  \vspace{3pt}

  The sub-expression \code{3 * (4 div 0)} of \code{1 + (3 * (4 div 0))} raises
  \code{Div}, so \code{1 + (3 * (4 div 0))} raises it too.

  \pause
  \vspace{3pt}

  The sub-expression \code{1 + (3 * (4 div 0))} of
  \code{1 + (3 * (4 div 0)) handle Div => 5} raises \code{Div}. Since this
  entire expression is a \code{handle}, we match \code{Div} to the
  handler's first case, and evaluate to \code{5}.

  \pause
  \vspace{\fill}

  This is an example of \textit{nonlocal control flow}, because when evaluating
  the expression \code{1 + (3 * (4 div 0))}, our \code{handle} expression
  lets us skip directly from a deeply nested \code{div} call directly back up
  to the handled expression!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptions and Options}

  Before, we saw there was a relationship between functions which returned
  options, and functions who instead raised exceptions.

  \pause
  \vspace{\fill}

  Let's generalize. Suppose we have a function \code{f : t1 -> t2},
  which is possibly exception-raising. Then, we can define \code{f_opt}
  with the following spec:

  \pause
  \spec
    {f_opt}
    {t1 -> t2 option}
    {\code{true}}
    {For all values \code{x : t1}: \\
    \vspace{5pt}
      \code{f_opt x} $\eeq$
    $\left\{
      \begin{array}{lr}
          \code{SOME res}, & \text{if } \code{f x} \hookrightarrow \code{res} \\
          \code{NONE}, & \text{if } \code{f x} \text{ raises an exception} \\
          \text{loops forever}, & \text{otherwise}
      \end{array}
    \right\}
    $
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptions and Options}

  Using \code{handle}, we can quickly go between these functions. Given
  \code{f}, as previously described, we define \code{f_opt : t1 -> t2} as:
  \begin{codeblock}
    fun f_opt x = (SOME (f x)) handle _ => NONE
  \end{codeblock}

  \pause
  \vspace{\fill}

  \customBox{Check your understanding}{\, Why did we have to surround \code{f x}
  with \code{SOME}? What would happen to the type if we didn't?}

  \pause
  \vspace{\fill}

  \badBox{}{\, It is a really bad idea to use \code{_} in a \code{handle} clause.
  This is because you might swallow up \textit{any} possible exception, rather
  than just the one you are interested in. This could obfuscate certain errors.}

  \pause
  \vspace{\fill}

  If you know the precise exception that \code{f} raises, it's better to case on
  that here.
\end{frame}

\begin{frame}[fragile]
  \frametitle{An Exceptional Example}

  Let's look at a particular example. Suppose we have the following function:

  \pause
  \vspace{\fill}

  \begin{codeblock}
    fun f x =
      ("Divided to " ^ Int.toString x)
      handle Div => "Divided by zero!"
  \end{codeblock}

  \pause
  \vspace{\fill}

  \customBox{Check your understanding}{\, Is it true that \code{f (1 div 0)} $\eeq$ \code{"Divided by zero!"}?}

  \pause
  \vspace{\fill}

  \textbf{Answer}: No, it is not! SML is an eagerly evaluated language, so the exception \code{Div}
  is raised before we enter the body of \code{f}. The handler never applies, because the handler is
  only within the definition of \code{f}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptions are a Side Effect}

  Exceptions are what we call a \term{side effect}.

  \pause
  \vspace{\fill}

  \defBox{}{A \term{side effect} is an effect of an expression which is not just
  computing a value. For instance, reading from a file, printing to the console,
  or raising an exception.\footnote{
    One can also consider infinite loops a side effect.
  }}

  \pause
  \vspace{\fill}

  Side effects tend to make our definitions of equivalence fuzzy. For instance,
  with exceptions, we cannot freely exchange the order of unrelated
  \code{val} bindings without possibly changing the behavior of the program:
  \begin{codeblock}
    val _ = raise Bind
    val _ = raise Match
  \end{codeblock}
  These two bindings are unrelated, but the order in which they happen
  matters! This can make mathematical reasoning annoying.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Equivalence and Addition}

  \ptsnmtmt

  Recall that our definition of extensional equivalence maintains that \code{e1 : t}
  and \code{e2 : t} are only extensionally equivalent if they evaluate to equivalent
  values, both loop forever, or \textbf{both raise the same exception}.

  \pause
  \vspace{\fill}

  A fun fact that goes along with that is that, in a world with exceptions, it is
  no longer true that \code{e1 + e2} $\eeq$ \code{e2 + e1}, where \code{e1, e2} are
  both expressions of type \code{int}.

  \pause
  \vspace{\fill}

  This is because \code{(raise Div) + (raise Bind)} raises \code{Div}, but
  \code{(raise Bind) + (raise Div)} raises \code{Bind}! This is another reason
  why \textit{valuability} (and by extension, totality) is important.
\end{frame}

\quizBreak{CHEMISTRY}

\sectionSlide{3}{Custom Exceptions}

\begin{frame}[fragile]
  \frametitle{An Exceptional \code{fact}}

  Suppose we wanted to revisit our old friend, \code{fact}.

  \begin{codeblock}
    fun fact 0 = 1
      | fact n = n * fact (n - 1)
  \end{codeblock}

  \pause
  \vspace{\fill}

  We know that \code{fact} loops forever on negative inputs. Generally,
  this is undesirable, because it can be difficult to discern an infinite
  loop from a program which is just taking a really long time.

  \pause
  \vspace{\fill}

  Let's define \code{fact_exn}\footnote{
    Labeling functions which possibly raise an exception
    with the suffix \code{_exn} is a common practice in the OCaml language,
    and in my opinion, a really good practice.
  }, which raises an exception on negative inputs!

  \pause
  \vspace{\fill}

  ...But what exception should we raise?
\end{frame}

\begin{frame}[fragile]
  \frametitle{Raising an Arbitrary Exception}

  We could define the following:
  \begin{codeblock}
    fun fact_exn 0 = 1
      | fact_exn n =
          if n < 0 then
            raise Bind
          else
            n * fact_exn (n - 1)
  \end{codeblock}

  \pause
  \vspace{\fill}

  But this isn't actually a case where we failed to produce a binding, which
  is what the \code{Bind} exception is supposed to be for. If we handled
  \code{Bind} elsewhere outside callers to this function, we might end up
  in a handler we didn't mean to!

  \pause
  \vspace{\fill}

  We could raise \code{Fail "negative number"}, but this becomes problematic
  to pattern match on. How can we do better?
\end{frame}

\begin{frame}[fragile]
  \frametitle{An Extensible Type}

  \tgs

  It turns out, we can! \code{exn} is a special type, because while it can be
  thought of as the \code{datatype} declared via
  \begin{codeblock}
    datatype exn = Match | Bind | Div | Fail of string | ...
  \end{codeblock}
  it's actually more special than that! \code{exn} is the only
  \term{extensible type}.\footnote{
    In fact, some say that \code{exn} stands for \textit{extensible}.
    Some people also say this is gaslighting, and it doesn't stand for that all, though.
  }

  \pause
  \vspace{\fill}

  \defBox{}{An \term{extensible type} is one where constructors can be
  added to it \textit{after the type is declared}. \code{exn} is the only
  example of this in Standard ML.}

  \pause
  \vspace{\fill}

  We can write something like
  \begin{codeblock}
    exception Fact
  \end{codeblock}
  to declare a new constructor \code{Fact : exn}, for the \code{exn} type.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Raising a Custom Exception}

  So now, we can define \code{fact_exn} better:
  \begin{codeblock}
    exception Fact

    fun fact_exn 0 = 1
      | fact_exn n =
          if n < 0 then
            raise Fact
          else
            n * fact_exn (n - 1)
  \end{codeblock}

  \pause
  \vspace{\fill}

  After this, the expression
  \begin{codeblock}
    (SOME (fact_exn (~1))) handle Fact => NONE
  \end{codeblock}
  will evaluate to \code{NONE}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptions of Arguments}

  We can also define exceptions which take in arguments:
  \begin{codeblock}
    exception Error of string

    fun runProcess (f : unit -> string) : string =
      ("OUTPUT: " ^ f ())
      handle Error s => ("ERROR: " ^ s)
  \end{codeblock}

  \pause
  \vspace{\fill}

  such that
  \code{runProcess (fn () => "foo")} $\hookrightarrow$ \code{"OUTPUT: foo"}

  \pause
  \vspace{\fill}

  and
  \code{runProcess (fn () => raise Error "bad")} $\hookrightarrow$ \code{"ERROR: bad"}
\end{frame}

\sectionSlide{4}{Exceptional Control Flow}

\begin{frame}[fragile]
  \frametitle{Implicit Control Flow}

  Exceptions are useful for writing code when we want to quickly be able to escape
  from some error case!

  \pause
  \vspace{\fill}

  We can also use them for their control-flow abilities. We saw in the last lecture
  how we can use continuations to make our control flow explicit, by passing
  around instructions on what to do in certain cases.

  \pause
  \vspace{\fill}

  With exceptions, we can go the other way and make our control flow even more implicit,
  by relying on casing on exceptions are raised.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptional Control Flow}

  For instance, let's do the \code{search} function using exceptions:

  \pause
  \spec
    {searchEHS}
    {('a -> bool) -> 'a tree -> 'a}
    {\code{p} is total}
    {\code{searchEHS p T} raises \code{NotFound} if there is no element in
    \code{T} that satisfies \code{p}. Otherwise, it returns the first element
    in its preorder traversal which does.}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptional Control Flow}
  \begin{codeblock}
    exception NotFound

    fun searchEHS p Empty = raise NotFound
      | searchEHS p (Node (L, x, R)) =
          if p x then
            x
          else
            (searchEHS p L) handle NotFound => searchEHS p R
  \end{codeblock}

  \pause
  \vspace{\fill}

  In this case, we handle the \code{NotFound} exception, which should be raised
  by our specification \textit{only} in the case where we fail to find a
  satisfying element in that subtree.

  \pause
  \vspace{\fill}

  This is known as \term{exception-handling style}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{EHS versus CPS}

  We can compare with the implementation of \code{search} using CPS we saw last lecture:

  \vspace{\fill}

  \begin{codeblock}
    fun searchCPS p Empty `sc fc` = `fc ()`
      | searchCPS p (Node (L, x, R)) `sc fc` =
          if p x then
            `sc` x
          else
            searchCPS p L
              `(fn res => sc res)`
              `(fn () =>` searchCPS p R `sc fc)`'
  \end{codeblock}

  \pause
  \vspace{\fill}

  We see that the \code{fc} cases correspond to our raising of the \code{NotFound} exception,
  and the success continuation corresponds simply to returning a value.

\end{frame}

\begin{frame}[fragile]
  \frametitle{On Exceptional Control Flow}

  Implicit control flow is generally a bad thing. While functions written in
  CPS \textit{can} be also written with exceptions, there is little reason to
  do this in actual code.

  \pause
  \vspace{\fill}

  This is largely because exceptions are a nightmare to debug. Nonlocal control
  flow transfer introduces precisely the problem that \code{goto} statements
  had, which is a lack of transparency!

  \pause
  \vspace{\fill}

  Business logic is generally better done without exceptions, but exceptions are
  great for error cases, when the program just needs to find a way to exit
  gracefully.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exception Handling On Steroids}

  We can go even more crazy with it. We can return data \textit{only} using
  exceptions.

  \pause
  \vspace{\fill}

  Consider the following specification:
  \spec
    {listmax_exn}
    {int list -> 'a}
    {\code{true}}
    { \\
      \code{listmax_exn L} $\eeq$
    $\left\{
      \begin{array}{lr}
          \code{raise (Max m)}, & \text{if } \code{m} \text{ is the max element of \code{L}} \\
          \code{raise NoMax}, & \text{if } \code{L} \eeq \code{[]}
      \end{array}
    \right\}
    $
    }

  \pause
  \vspace{\fill}

  This function never evaluates to a value.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exception Handling On Steroids}

  We can then implement \code{listmax_exn} like so:

  \begin{codeblock}
    exception NoMax
    exception Max of int

    fun listmax_exn []  = raise NoMax
      | listmax_exn [x] = raise (Max x)
      | listmax_exn (x::xs) =
          (listmax_exn xs) handle
            Max y => raise (Max (Int.max (x, y)))
  \end{codeblock}

  \pause
  \vspace{\fill}

  There's very little reason to do this. But it sure looks fun.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conclusions}

  There is nothing inherently wrong with exceptions. Because of the fact that
  they are not represented in the type system whatsoever, generally there is a
  preference to avoid them where possible, but there are use cases.

  \pause
  \vspace{\fill}

  When dealing with cases where preconditions really are very clear, it is not
  wrong to use functions which can possibly be exception-raising, \textit{so
  long as to do otherwise would be a significant detriment}. Clean code comes
  first, but not at the risk of compromising the safety of our software!

  \pause
  \vspace{\fill}

  A very common use case for exceptions is to implement error handling, when
  the software definitely does not need to resume, but can just print out
  information, and then exit.
\end{frame}


% \begin{frame}[plain]
% 	\begin{center} Thank you! \end{center}

% 	\begin{center}
%     {\color{blue} \href{https://docs.google.com/forms/d/e/1FAIpQLSf7yaK02wbqwWgBHUMDapwgQYGXkhFVuivS6GdToCJ11zUCrQ/viewform?usp=sf_link}{Post-lecture survey:}} \\
%     \vspace{5pt}
%     \includegraphics[scale=0.035]{qr_june22}
%   \end{center}
% \end{frame}

\thankyou

\end{document}
