% Jacob Neumann

% DOCUMENT CLASS AND PACKAGE USE
    \documentclass[aspectratio=169]{beamer}
 
    % Establish the colorlambda boolean, to control whether the lambda is solid color (true), or the same as the picture (false)
    \newif\ifcolorlambda
    \colorlambdafalse % DEFAULT: false
    
    % Use auxcolor for syntax highlighting
    \newif\ifuseaux
    \useauxfalse % DEFAULT: false
   
    % Color settings
    \useauxtrue
    
    \newcommand{\auxColor}{2791e3}
    \newcommand{\presentColor}{2e2e2e} % the primary color of the slide borders
    \newcommand{\bgColor}{d6d6d6}      % the color of the background of the slide
    \newcommand{\darkBg}{8b98ad}
    \newcommand{\lambdaColor}{\auxColor}
  
    \colorlambdatrue

    \usepackage{comment} % comment blocks
    \usepackage{soul} % strikethrough
    \usepackage{listings} % code
    \usepackage{makecell}

    \setbeamertemplate{itemize items}[circle]
    % \setbeameroption{show notes on second screen=right}

    \usepackage{lectureSlides}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%| <----- Don't make the title any longer than this
    \title{1 - Prologue} % TODO
    \subtitle{Awesome slides with an awesome subtitle} % TODO
    \date{01 January 2020} % TODO
    \author{Brandon Wu} % TODO

    \graphicspath{ {./img/} }
    % DONT FORGET TO PUT [fragile] on frames with codeblocks, specs, etc.
        %\begin{frame}[fragile]
        %\begin{codeblock}
        %fun fact 0 = 1
        %  | fact n = n * fact(n-1)
        %\end{codeblock}
        %\end{frame}

    % INCLUDING codefile:
        % 1. In some file under code/NN (where NN is the lecture id num), include:
    %       (* FRAGMENT KK *)
    %           <CONTENT>
    %       (* END KK *)
    
    %    Remember to not put anything on the same line as the FRAGMENT or END comment, as that won't be included. KK here is some (not-zero-padded) integer. Note that you MUST have fragments 0,1,...,KK-1 defined in this manner in order for fragment KK to be properly extracted.
        %  2. On the slide where you want code fragment K
                % \smlFrag[color]{KK}
        %     where 'color' is some color string (defaults to 'white'. Don't use presentColor.
    %  3. If you want to offset the line numbers (e.g. have them start at line 5 instead of 1), use
                % \smlFragOffset[color]{KK}{5}

\begin{document}

% Make it so ./mkWeb works correctly
\ifweb
    \renewcommand{\pause}{}
\fi

\setbeamertemplate{itemize items}[circle]

% SOLID COLOR TITLE (see SETTINGS.sty)
\begin{comment}
{
\begin{frame}[plain]
    \colorlambdatrue
    \titlepage
\end{frame}
}
\end{comment}

\begin{comment}
  Future Retro from ANIMUSIC plays as students walk in
  When the music ends, BRANDON bursts in through the door

  HELLO EVERYONE! Welcome to 15-150, Principles of Functional Programming.

  I'm super excited to have all of you here. My name is Brandon Wu, and I'll be your
  primary instructor for this summer. Please call me Brandon, though confusingly
  there is also a TA named Brandon, so I guess we'll have to just figure that one out.

  To properly introduce myself, I'm actually a recent graduate of CMU, I graduated
  with my bachelor's degree in computer science last spring, and when I was in undergrad,
  I TA'd this class five times, and I was Head TA for two semesters. While I am lucky
  enough to teach this course to you this summer, I have a full-time job working  
  for a company called Semgrep in the Bay, where I actually do functional programming
  every single day.

  With intros over, let's hop to it. Today we're here to learn functional programming.
\end{comment}

\begin{frame}[fragile]
  \frametitle{Lesson Plan}

  \tableofcontents
\end{frame}

\sectionSlide{1}{The Philosophy of Functional Programming}

\begin{frame}[fragile]
  \frametitle{What is Functional Programming?}

  \pause

  \begin{center}
    What is functional programming?
  \end{center}

  \pause

  \vspace{\fill}

  \begin{center}
    Well, hold up. What is programming?
  \end{center}

  \note{
    To many of you, this is likely a brand new topic, and that's perfectly OK. How do I 
    like to describe it? Functional programming is a kind of paradigm of programming,
    like object-oriented or imperative programming. It's a kind of style, but deeper than
    the sense of MLA or Chicago style. It's not just how you format the text, but it's a
    philosophically different style of programming. 

    Before I can go into the philosophy of functional programming though, I'd like to 
    detour a bit and talk about programming.
  }
\end{frame}


\begin{frame}[fragile]
  \frametitle{What is Programming?}

  \note{
    So, some of you might have an answer to this question. What is programming? \\
  }

  \pause
  \fontfamily{phv}\selectfont

  \begin{center} 
    Programming is the act of \textbf{instructing a computer on how to achieve some kind of operation.} 
  \end{center}

  \note{
    Programming is the act of instructing a computer on how to achieve some kind of operation. \\

    This might be something like computing the square root of a number, or searching a paragraph
    of text for a particular keyword, or ordering a pizza online. All of you have programmed before,
    so you're familiar with the concept, I'm sure. \\
  }

  \pause

  \vspace{5pt}

  \begin{center} 
    Programming is \textbf{inherently a communicative act.}
  \end{center}

  \pause
  \vspace{\fill}

  \textbf{Instructing} is the key word. Good communication exists, so what is good programming?

  \pause
  \vspace{\fill}

  \begin{center} 
    Functional programming is \textbf{an improvement on our ability to communicate as programmers}.
  \end{center}

  \note{
    The key part of that description, however, is \textit{instruction}. You can instruct someone in lots
    of different ways. It all boils down to someone's particular communication style. In
    that way, programming is inherently a communicative act. It's not just math or computer science, it's
    \textit{linguistic}. I'm sure many of you have read bad code before. \\ 

    So, we know that some things make good communication, but what things make good programming?
  }

  \vspace{\fill}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What should programming be?}

  \begin{center}
    Good programming should be \textbf{descriptive}. \\

    \vspace{\fill}

    \includegraphics[scale=0.35]{goto.jpeg}
  \end{center}

  \note{
    So how can we characterize good programming? \\ 
    
    Well, for starters, programming should be descriptive. Good code should be self-documenting,
    in the sense that you can read it easily and figure out what's going on. This is something that is
    more subtle than just the names of your variables or the layout of your code, however. \\

    When I think about descriptive code, I'm always reminded of this old paper of Edgar Dijkstra,
    one of the pioneers of the field of computer science. You might know about it. It was called
    "Go To Statement Considered Harmful", and it was basically a treatise against something called
    a "go to statement". Before the days of loops and conditionals, there was the goto, which was
    basically an unrestricted teleportation cheat code. It said, go here and start doing this 
    instead. It was the wild west of programming, where programs could sometimes just go and
    start doing something completely different, and it made programs extremely hard to read. \\

    So when I say programs should be descriptive, I mean in a more \textit{fundamental} way that is
    internal to what the program \textit{actually means}. And this can vary, from language to language.
    In some languages, it's quite easy to express something than in another, but it goes deeper than
    just syntax. \\
  }
\end{frame}


\begin{frame}[fragile]
  \frametitle{What should programming be?}
  \begin{center}
    Good programming should be \textbf{modular}.

    \pause
    \vspace{\fill}

    Logically distinct parts should be separated, for separate maintenance and reuse.

    \pause
    \vspace{\fill}

    You should be able to think about a single area of a codebase without needing to
    concern yourself with unrelated logic.


  \end{center}

  \note{
    Next, good programming should be modular. You've probably heard this before, but modularity
    in code basically just means that things should be broken up into logically distinct parts.
    If I go and order a pizza online, there's probably a step where I need to figure out what
    size pizza I want, how many pizzas to order. There's a step to pick the toppings I want on
    my pizza, a step to enter my information, like where to deliver it to, and a step to enter my
    payment credentials so I can order it officially. \\

    All of these steps are logically distinct, when I explain them to you with words. Programming
    should be the same way. I should be able to write a program which carries out all those steps,
    without them stepping on each others toes and getting in each other's way. So, we should write
    modular code, which is ideally reusable and easy to understand. \\
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{What should programming be?}

  \begin{center}
    Good programming should be \textbf{maintainable}.
  \end{center}

  \note {
    And finally, good programming should be maintainable. It should be very easy to go and make
    changes to code, when a problem statement is revised slightly, and it should be very easy to
    change one part of a codebase without affecting all the rest of it. This goes hand-in-hand
    with modularity and descriptivity -- I can't go and modify code I don't understand.
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{What is Not Functional Programming?}

  \note { 
    So, now that we've identified some things that programming should ideally be, we can return 
    to this discussion of functional programming. What is functional programming? \\

    Functional programming is a conglomeration of different ideas, so there's not a one-size 
    fits-all description for it, but I think the primary differences are along a few axes. 
    So, I'll push back on that again, and answer the slightly easier question of what functional
    programming is not. Let's start with an example of code written in Python. \\
  }

  Let's look at an example of non-functional code in Python.

  \pause

  \begin{lstlisting}[language=Python]
    count = 0

    def increment():
      global count 
      count += 1 

      return count
  \end{lstlisting}

  \pause

  What does \code{increment()} return?

  \pause

  \vspace{\fill}

  \note { 
    The answer: It depends! It's not clear what this function might return, because it
    depends on when you call it. This is the notion of "state" in a program. \\
  }

  The answer: \textbf{it depends}. On the first call, it returns \code{1}, and on the
  second call, \code{2}, and so on.
  
  \pause

  \vspace{\fill}

  This demonstrates what we call \term{state}.

\end{frame}

\begin{frame}[fragile]
  \frametitle{Programming, By Analogy}

  Suppose you are a master chef at a 5-star restaurant.

  \pause
  \vspace{\fill}

  An imperative program is like a fully crowded kitchen with no rules. 
  \begin{itemize}
    \item Everyone uses the same ingredients and the same cookware. \\

    \item \textbf{Each cook is an individual actor that can mess with the others}, if
    care is not taken. The health of the kitchen depends on each individual chef.
  \end{itemize}

  \pause
  \vspace{\fill}

  A functional program is like a kitchen where each cook has their own working space. 

  \begin{itemize}
    \item Everyone has their own pots, pans, and ingredients, and they only share things when
    they finish producing their individual parts. 

    \item \textbf{Each cook only interacts when sharing finished results}. This means
    it is impossible for one cook's actions to mess up another's cooking. 
  \end{itemize}

  \note {
    The imperative kitchen is faster, at the risk of salmonella.
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Programming, Two Ways}

  \begin{center}
  \begin{tabular}{p{0.34\linewidth} @{\hspace{0.75in}} p{0.35\linewidth}}
    Programming, Imperatively & Programming, Functionally \\ \\
    Computation by \textbf{modifying the computer's state} & 
    Computation by \textbf{reduction of expressions to values} \\ \pause \\
    \makecell{\Large \code{x := 2;} \\ \\ \vspace{25pt} \Large \code{x + x}} & 
    \makecell{\Large \code{2 + 2}}
  \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Programming, Two Ways}

  \note {
    There are a few ways that we can contrast imperative and functional programming,
    but this notion of "state" is going to be a big one. \\

    In an imperative program, you compute by changing the state of the computer, 
    until eventually you can produce the answer you need. This means that any given
    computation depends on what has happened before, and any step might not make sense if
    you reorder them in a certain way. \\
  }

  In stateful programs, we use commands like \code{x := 2} to \textit{change the world},
  to be one where \code{x + x} is 4.

  \vspace{4pt}

  This doesn't stop another part of the program from changing that later!

  \pause
  \vspace{\fill}

  In functional programs, we apply simplifying rules to expressions like \code{2 + 2},
  to obtain the value of \code{4}. 

  \vspace{4pt}
  
  These expressions are \textbf{disjoint}, in that evaluation of one expression
  is unrelated to the evaluation of another.
  

  \note { 
    In a functional program, you compute by taking expressions, and reducing them to
    values. You can then combine the results of these expressions in different ways to
    compute a final answer. The difference is that each individual expression, each step,
    is independent of the other. This means that they can be done in parallel, they can be
    done in an arbitrary order, and they can be analyzed and determined independently
    of each other.
  }

  \pause
  \vspace{\fill}

  \note {
    In an imperative program, you need to not only understand what code does, but you
    might need to know exactly when the code has been run. This makes it really hard
    to understand programs, but functional programming has a big win here.
  }
  
  In stateful programs, understanding a program entails not only understanding what the code does,
  but knowing the entire history of the program up until that point.

\end{frame}

\begin{frame}[fragile]
  \frametitle{What is functional programming?}

  Functional programming \textbf{avoids modification of state}.

  \pause
  \vspace{\fill}

  \defBox{\, Code is \textit{pure} if it does not have any observable side effects, and always
  returns the same outputs, given the same inputs.}

  \pause
  \vspace{\fill}

  A large amount of problems in computer science are of a pure nature. This means that they
  give the same outputs for the same inputs.
  (For example, finding the shortest path through a graph, computing the \textit{n}th prime
  number, or compressing a file)

  \pause
  \vspace{5pt}

  An important motivation behind functional programming will end up being that we should 
  prefer to solve pure problems with pure components. In other words, don't introduce state
  when it's not necessary!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Three Theses}
  \vspace{\fill}

  Functional programming can be characterized by three theses, which will be a recurring
  theme throughout the semester. 

  \pause 

  \vspace{\fill}

  { \Large
  \begin{enumerate}
    \item Recursive Problems, Recursive Solutions
    \pause
    \vspace{\fill}
    \item Programmatic Thinking is Mathematical Thinking
    \pause
    \vspace{\fill}
    \item Types Guide Structure
  \end{enumerate}
  }

\end{frame}

\begin{frame}[plain]

  \begin{center}
    \Large 5-minute break!
  \end{center}

\end{frame}

\sectionSlide{2}{Types, Expressions, Values}

\begin{frame}[plain]
  \frametitle{The Standard ML Language}

  In this class, we will be using a functional programming language called Standard ML (SML).

  \vspace{10pt}

  Mantra: In Standard ML, \textbf{computation is evaluation}.

  { \Large
  \begin{align*}
    \code{(2 + 3) * 4} &\stepsTo \code{5 * 4} \\ 
    &\stepsTo \code{20}
  \end{align*}
  }

  \vspace{\fill}

  \defBox{\, We use the $\stepsTo$ symbol to denote \term{stepping} (or \term{reducing}) of expressions,
  which means to simplify an expression by one step.}

  \vspace{5pt}
  
  So the expression \code{5 * 4} \textit{steps to} the expression \code{20}.
\end{frame}

\begin{frame}[plain]
  \frametitle{Computation as Evaluation}

  We call the previous slide the \term{computation trace} of the expression \code{(2 + 3) * 4}. \\ 

  \vspace{5pt}

  The goal of a computation trace is to produce a value.

  \pause

  \vspace{10pt}

  \defBox{\, An \term{expression} is the building block of an SML program. These 
  may or may not step to another expression.}

  \pause
  \vspace{\fill}

  \defBox{\, A \term{value} is a \textbf{final answer}, that cannot be simplified further.}

  \vspace{5pt}

  Examples include \code{2}, \code{\"hi\"}, and \code{true}.

  \pause
  \vspace{\fill}

  If we know that the expression \code{e} eventually reduces down to value \code{v}, we might
  say that \code{e} reduces to \code{v}, or write \code{e} $\hookrightarrow$ \code{v}. We then say
  that \code{e} is \term{valuable}.

  \vspace{5pt}

  So \code{(2 + 3) * 4} $\hookrightarrow$ \code{20}.

\end{frame}

\begin{frame}[plain]
  \frametitle{Computation without Valuation}

  We said before that the goal of a computation trace is to produce a value, but not 
  all expressions do!

  \pause
  \vspace{\fill}

  What value does the expression \code{1 div 0} reduce to?

  \pause
  \vspace{\fill}

  The answer: \textbf{there is no such value!} Division by zero is undefined, and in
  Standard ML, raises an exception.

  \pause
  \vspace{\fill}

  Evaluating an expression has three possible behaviors:
  \begin{itemize}
    \item Reducing to a value
    \item Raising an exception
    \item Looping forever
  \end{itemize}

\end{frame}

\begin{frame}[plain]
  \frametitle{Computation without Meaning}

  In Standard ML, the string concatenation operator is \code{^}.

  \vspace{5pt}

  So we would say that \code{"hi" ^ "there"} $\stepsTo$ \code{"hithere"}.

  \pause
  \vspace{5pt}

  But what does \code{"1" ^ 50} step to?

  \pause
  \vspace{\fill}

  Some programming languages might try to make sense of this expression.

  \vspace{5pt}

  \textbf{Standard ML will not.}
\end{frame}

\begin{frame}[plain]
  \frametitle{Types}

  \defBox{\, A \term{type} is a specification of the behavior of a piece of code. It 
  \textbf{predicts} what a program is allowed to do.}

  \pause
  \vspace{5pt}

  We write \code{e : t} to say that the expression \code{e} has type \code{t}, so 
  we could write \code{ 1 + (2 * 3) : int }.

  \pause
  \vspace{\fill}

  For instance, something with type \code{int} must produce a number, if it reduces to a value.

  \vspace{5pt}

  Similarly with something of type \code{string}.

  \pause
  \vspace{\fill}

  What can we say about the runtime behavior of \code{"1" ^ 50}? It's not clear, so 
  the expression \code{"1" ^ 50} \textbf{does not have a type}.
\end{frame}

\begin{frame}[plain]
  \frametitle{Typing Trace}

  How does Standard ML know the type of an expression?

  \vspace{5pt}

  It follows \term{typing rules} to determine this. For instance: 

  \pause
  \vspace{\fill}
  
  \defBox{\, The typing rule for \code{+} is: \code{e1 + e2 : int} if \code{e1 : int} 
  and \code{e2 : int}
  }

  \pause
  \vspace{\fill}

  Take the expression \code{1 + (2 + 3)}.

  \pause
  \vspace{\fill}

  Then, we know \code{1 + (2 + 3) : int} if \code{1 : int} and \code{2 + 3 : int}.
  \pause
  \vspace{3pt}

  We know \code{1 : int}.
  \pause
  \vspace{3pt}

  Then, we know \code{2 + 3 : int} if \code{2 : int} and \code{3 : int}.
  \pause
  \vspace{3pt}

  We know \code{2 : int}.
  \pause
  \vspace{3pt}

  We know \code{3 : int}.
  \pause
  \vspace{3pt}

  So \code{1 + (2 + 3) : int}.
\end{frame}

\begin{frame}[plain]
  \frametitle{Ill-Typing Trace}

  What about for \code{"1" ^ 50}?

  \pause
  \vspace{\fill}

  \defBox{\, The typing rule for \code{^} is: \code{e1 + e2 : string} if \code{e1 : string} 
  and \code{e2 : string}
  }

  \pause
  \vspace{\fill}

  Take the expression \code{"1" ^ 50}. 

  \pause
  \vspace{\fill}

  Then, we know \code{"1" ^ 50 : string} if \code{"1" : string} and \code{50 : string}.

  \pause
  \vspace{3pt}

  We know \code{"1" : string}.

  \pause
  \vspace{3pt}

  However, it is not true that \code{50 : string}, because \code{50 : int}.

  \pause
  \vspace{\fill}

  So \code{"1" ^ 50} does not have a type, and we say it is an \term{ill-typed expression}.
\end{frame}


\begin{frame}[plain]
  \frametitle{Static Typing}

  SML is a \term{statically typed} language, meaning that all typing rules are applied
  \textbf{before the program is ever run}.

  \pause
  \vspace{\fill}

  \defBox{ We say that a piece of code or a program which obeys all the typing rules
  \term{type-checks}, or is \term{well-typed}.
  }

  \pause
  \vspace{\fill}

  \keyBox{\, \textbf{Ill-typed programs are not evaluated.} } 
\end{frame}







\begin{comment}
  So here's my prolegomena for you. Before we can do any functional programming, I need to
  set the stage a little bit.

  How many of you have heard of functional programming? Raise your hands, now.

  OK, now how many of you have ever done functional programming?

  Raise your hands if you love functional programming (I raise my hand)

  Before I can teach you functional programming, I think it's necessary to be transparent
  with you. Functional programming is a style of programming, closely associated with some
  particular programming languages, like Haskell, or the one we will use in this class,
  Standard ML. 
  
  Here's the fact. Functional programming languages are not very popular. Almost all of 
  you will never touch the language we will use in this class again, after college. There's
  many people in the world who have never used a functional programming language in their
  life, and there's many computer science programs in the country that don't even teach
  the subject. In this class, you are going to face problems and scenarios that are different 
  than anything that you've ever seen before, and you're going to wonder "why can't I just 
  do it a different way?" 

  You might be thinking, "this is a weird way to sell me on your class", but humor me for a second.
  I'm going somewhere with this.

  All programming is functional programming.

  I'm not here to try and teach you a singular, monolithic tool. The ideas that we are going 
  to go over the course of this summer are ones that permeate far beyond a single language, 
  or a single tool, or a single class. What you are going to learn in this class are general 
  principles that are going to make you better programmers, better computer scientists, and 
  better engineers. I'm not asking for you to love functional programming. I'm asking to change
  your life. And that, I believe, is the true merit of functional programming.

  So yes, functional programming is a niche topic. It's not something that's taught in every
  university in the world. But look where you're sitting now. This is Carnegie Mellon, home
  to the best computer science program in the entire world, and you have the privilege of
  learning something that very few other programs even teach at all. You're learning something
  far from obscure -- everyone else is just playing catch-up.

  Welcome to 15-150! That's the end of my prolegomena to you. 
\end{comment}

\begin{frame}[fragile]
    \frametitle{The Course Staff}

    \begin{center} \includegraphics[scale=0.25]{me_smaller.jpg} \end{center}
    \begin{center} \Large Brandon Wu \end{center}
    
    \vspace{\fill}

    \begin{center}\begin{tabular}{c c c c c c}
      TA 1 & TA 2 & TA 3 & TA 4 & TA 5 & TA 6 \\  
      \includegraphics[scale=0.15]{default} &
      \includegraphics[scale=0.15]{default} &
      \includegraphics[scale=0.15]{default} &
      \includegraphics[scale=0.15]{default} &
      \includegraphics[scale=0.15]{default} &
      \includegraphics[scale=0.15]{default} \\
    \end{tabular}\end{center}

\end{frame}


\begin{frame}[fragile]
    \frametitle{Course Logistics}

    \begin{itemize}
      \item Homework every week -- due on <date>
      \item Turn in assignments via Gradescope
      \item Receive assignments via Canvas
      \item Piazza for questions, TA help
    \end{itemize}

\end{frame}

\begin{frame}[plain]
	\begin{center} Thank you! \end{center}
\end{frame}


\end{document}

